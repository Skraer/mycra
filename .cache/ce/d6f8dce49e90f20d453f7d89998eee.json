{"id":"node_modules/@bcoe/v8-coverage/dist/lib/ascii.js","dependencies":[{"name":"/Users/ruslanidrisov/programming/projects/mycra/mycra/package.json","includedInParent":true,"mtime":1592223810651},{"name":"/Users/ruslanidrisov/programming/projects/mycra/mycra/node_modules/@bcoe/v8-coverage/dist/lib/package.json","includedInParent":true,"mtime":499162500000},{"name":"./compare","loc":{"line":3,"column":26},"parent":"/Users/ruslanidrisov/programming/projects/mycra/mycra/node_modules/@bcoe/v8-coverage/dist/lib/ascii.js","resolved":"/Users/ruslanidrisov/programming/projects/mycra/mycra/node_modules/@bcoe/v8-coverage/dist/lib/compare.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst compare_1 = require(\"./compare\");\nfunction emitForest(trees) {\n    return emitForestLines(trees).join(\"\\n\");\n}\nexports.emitForest = emitForest;\nfunction emitForestLines(trees) {\n    const colMap = getColMap(trees);\n    const header = emitOffsets(colMap);\n    return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\nexports.emitForestLines = emitForestLines;\nfunction getColMap(trees) {\n    const eventSet = new Set();\n    for (const tree of trees) {\n        const stack = [tree];\n        while (stack.length > 0) {\n            const cur = stack.pop();\n            eventSet.add(cur.start);\n            eventSet.add(cur.end);\n            for (const child of cur.children) {\n                stack.push(child);\n            }\n        }\n    }\n    const events = [...eventSet];\n    events.sort((a, b) => a - b);\n    let maxDigits = 1;\n    for (const event of events) {\n        maxDigits = Math.max(maxDigits, event.toString(10).length);\n    }\n    const colWidth = maxDigits + 3;\n    const colMap = new Map();\n    for (const [i, event] of events.entries()) {\n        colMap.set(event, i * colWidth);\n    }\n    return colMap;\n}\nfunction emitTree(tree, colMap) {\n    const layers = [];\n    let nextLayer = [tree];\n    while (nextLayer.length > 0) {\n        const layer = nextLayer;\n        layers.push(layer);\n        nextLayer = [];\n        for (const node of layer) {\n            for (const child of node.children) {\n                nextLayer.push(child);\n            }\n        }\n    }\n    return layers.map(layer => emitTreeLayer(layer, colMap));\n}\nfunction parseFunctionRanges(text, offsetMap) {\n    const result = [];\n    for (const line of text.split(\"\\n\")) {\n        for (const range of parseTreeLayer(line, offsetMap)) {\n            result.push(range);\n        }\n    }\n    result.sort(compare_1.compareRangeCovs);\n    return result;\n}\nexports.parseFunctionRanges = parseFunctionRanges;\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\nfunction emitTreeLayer(layer, colMap) {\n    const line = [];\n    let curIdx = 0;\n    for (const { start, end, count } of layer) {\n        const startIdx = colMap.get(start);\n        const endIdx = colMap.get(end);\n        if (startIdx > curIdx) {\n            line.push(\" \".repeat(startIdx - curIdx));\n        }\n        line.push(emitRange(count, endIdx - startIdx));\n        curIdx = endIdx;\n    }\n    return line.join(\"\");\n}\nfunction parseTreeLayer(text, offsetMap) {\n    const result = [];\n    const regex = /\\[(\\d+)-*\\)/gs;\n    while (true) {\n        const match = regex.exec(text);\n        if (match === null) {\n            break;\n        }\n        const startIdx = match.index;\n        const endIdx = startIdx + match[0].length;\n        const count = parseInt(match[1], 10);\n        const startOffset = offsetMap.get(startIdx);\n        const endOffset = offsetMap.get(endIdx);\n        if (startOffset === undefined || endOffset === undefined) {\n            throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n        }\n        result.push({ startOffset, endOffset, count });\n    }\n    return result;\n}\nfunction emitRange(count, len) {\n    const rangeStart = `[${count.toString(10)}`;\n    const rangeEnd = \")\";\n    const hyphensLen = len - (rangeStart.length + rangeEnd.length);\n    const hyphens = \"-\".repeat(Math.max(0, hyphensLen));\n    return `${rangeStart}${hyphens}${rangeEnd}`;\n}\nfunction emitOffsets(colMap) {\n    let line = \"\";\n    for (const [event, col] of colMap) {\n        if (line.length < col) {\n            line += \" \".repeat(col - line.length);\n        }\n        line += event.toString(10);\n    }\n    return line;\n}\nfunction parseOffsets(text) {\n    const result = new Map();\n    const regex = /\\d+/gs;\n    while (true) {\n        const match = regex.exec(text);\n        if (match === null) {\n            break;\n        }\n        result.set(match.index, parseInt(match[0], 10));\n    }\n    return result;\n}\nexports.parseOffsets = parseOffsets;\n\n\n"},"sourceMaps":{"js":{"version":3,"sources":["_src/ascii.ts"],"names":[],"mappings":"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","file":"ascii.js","sourcesContent":["import { compareRangeCovs } from \"./compare\";\nimport { RangeCov } from \"./types\";\n\ninterface ReadonlyRangeTree {\n  readonly start: number;\n  readonly end: number;\n  readonly count: number;\n  readonly children: ReadonlyRangeTree[];\n}\n\nexport function emitForest(trees: ReadonlyArray<ReadonlyRangeTree>): string {\n  return emitForestLines(trees).join(\"\\n\");\n}\n\nexport function emitForestLines(trees: ReadonlyArray<ReadonlyRangeTree>): string[] {\n  const colMap: Map<number, number> = getColMap(trees);\n  const header: string = emitOffsets(colMap);\n  return [header, ...trees.map(tree => emitTree(tree, colMap).join(\"\\n\"))];\n}\n\nfunction getColMap(trees: Iterable<ReadonlyRangeTree>): Map<number, number> {\n  const eventSet: Set<number> = new Set();\n  for (const tree of trees) {\n    const stack: ReadonlyRangeTree[] = [tree];\n    while (stack.length > 0) {\n      const cur: ReadonlyRangeTree = stack.pop()!;\n      eventSet.add(cur.start);\n      eventSet.add(cur.end);\n      for (const child of cur.children) {\n        stack.push(child);\n      }\n    }\n  }\n  const events: number[] = [...eventSet];\n  events.sort((a, b) => a - b);\n  let maxDigits: number = 1;\n  for (const event of events) {\n    maxDigits = Math.max(maxDigits, event.toString(10).length);\n  }\n  const colWidth: number = maxDigits + 3;\n  const colMap: Map<number, number> = new Map();\n  for (const [i, event] of events.entries()) {\n    colMap.set(event, i * colWidth);\n  }\n  return colMap;\n}\n\nfunction emitTree(tree: ReadonlyRangeTree, colMap: Map<number, number>): string[] {\n  const layers: ReadonlyRangeTree[][] = [];\n  let nextLayer: ReadonlyRangeTree[] = [tree];\n  while (nextLayer.length > 0) {\n    const layer: ReadonlyRangeTree[] = nextLayer;\n    layers.push(layer);\n    nextLayer = [];\n    for (const node of layer) {\n      for (const child of node.children) {\n        nextLayer.push(child);\n      }\n    }\n  }\n  return layers.map(layer => emitTreeLayer(layer, colMap));\n}\n\nexport function parseFunctionRanges(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  for (const line of text.split(\"\\n\")) {\n    for (const range of parseTreeLayer(line, offsetMap)) {\n      result.push(range);\n    }\n  }\n  result.sort(compareRangeCovs);\n  return result;\n}\n\n/**\n *\n * @param layer Sorted list of disjoint trees.\n * @param colMap\n */\nfunction emitTreeLayer(layer: ReadonlyRangeTree[], colMap: Map<number, number>): string {\n  const line: string[] = [];\n  let curIdx: number = 0;\n  for (const {start, end, count} of layer) {\n    const startIdx: number = colMap.get(start)!;\n    const endIdx: number = colMap.get(end)!;\n    if (startIdx > curIdx) {\n      line.push(\" \".repeat(startIdx - curIdx));\n    }\n    line.push(emitRange(count, endIdx - startIdx));\n    curIdx = endIdx;\n  }\n  return line.join(\"\");\n}\n\nfunction parseTreeLayer(text: string, offsetMap: Map<number, number>): RangeCov[] {\n  const result: RangeCov[] = [];\n  const regex: RegExp = /\\[(\\d+)-*\\)/gs;\n  while (true) {\n    const match: RegExpMatchArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    const startIdx: number = match.index!;\n    const endIdx: number = startIdx + match[0].length;\n    const count: number = parseInt(match[1], 10);\n    const startOffset: number | undefined = offsetMap.get(startIdx);\n    const endOffset: number | undefined = offsetMap.get(endIdx);\n    if (startOffset === undefined || endOffset === undefined) {\n      throw new Error(`Invalid offsets for: ${JSON.stringify(text)}`);\n    }\n    result.push({startOffset, endOffset, count});\n  }\n  return result;\n}\n\nfunction emitRange(count: number, len: number): string {\n  const rangeStart: string = `[${count.toString(10)}`;\n  const rangeEnd: string = \")\";\n  const hyphensLen: number = len - (rangeStart.length + rangeEnd.length);\n  const hyphens: string = \"-\".repeat(Math.max(0, hyphensLen));\n  return `${rangeStart}${hyphens}${rangeEnd}`;\n}\n\nfunction emitOffsets(colMap: Map<number, number>): string {\n  let line: string = \"\";\n  for (const [event, col] of colMap) {\n    if (line.length < col) {\n      line += \" \".repeat(col - line.length);\n    }\n    line += event.toString(10);\n  }\n  return line;\n}\n\nexport function parseOffsets(text: string): Map<number, number> {\n  const result: Map<number, number> = new Map();\n  const regex: RegExp = /\\d+/gs;\n  while (true) {\n    const match: RegExpExecArray | null = regex.exec(text);\n    if (match === null) {\n      break;\n    }\n    result.set(match.index, parseInt(match[0], 10));\n  }\n  return result;\n}\n"],"sourceRoot":""}},"error":null,"hash":"187b6cd00c9a9ced74c2a1c139147fbb","cacheData":{"env":{}}}